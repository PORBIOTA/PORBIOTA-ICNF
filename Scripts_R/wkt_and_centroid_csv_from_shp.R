######################################################
#                      LIBRARY                       #
######################################################

# install.packages("tidyverse")
# install.packages("sf")
# install.packages("sp")
# install.packages("rgeos")
# install.packages("spatstat")
# install.packages("spatialEco")


library("spatialEco")
library("sf")
library("sp")
library("tidyverse")
library("rgeos")
library("spatstat")

######################################################
#                 Define Paths                       #
######################################################


####Adjust according to RAM. Around 20000 for each 8gb is a possibly safe value.
linesLimit = 20000

#Set the path to shapefile
path = "D:\\Porbiota\\Datasets\\Art12_birds_distribution\\pt_art12_aves_distribuicao_centroids_intersected\\pt_art12_aves_distribuicao_centroids_intersected.shp" 
encoding = 'CP1252' #It is probably the correct one given the datasets until now, might change though.
 
###Set output FOLDER
output_path = "C:\\testerun\\"
 
#######Put complete CAOP2020 shape in WGS84 #############
CAOPpath = "D:\\Porbiota\\Datasets\\Helper_Files\\CAOP2020_WGS84.shp"
#Available here: https://drive.google.com/file/d/1op8QLvgU7e0kwfTmvraKLdQsHCx_PAHP



####################################################################################################
#########################From here no need to edit anything, just run it all########################
####################################################################################################

shape=st_read(path)
CAOP <- st_as_sf(st_read(CAOPpath))

numberOfRows = nrow(shape)

rm(shape)
gc()


##Function to calculate coordinate precision
coordCalc <- function(x,y,z,ROUND,slotCall) {
	v <- slot(slot(x,slotCall)[[1]],"coords")  # Polygon vertices
	
	##Runs through multipolygons
	a <- 1
	while (a < length(slot(x,slotCall))) {
	a <- a+1
		v <- rbind(v,slot(slot(x,slotCall)[[a]],"coords"))
	}
	
	d <- crossdist(v[,1], v[,2], y, z)
	i1 <- which.max(d[,1]) 
	if(ROUND) {
		round(d[i1])
	} else {

		d[i1]

	}
}


### Function to get centroids or inside centroids depending on needs
st_centroid_within_poly <- function (poly) {

  # check if centroid is in polygon
  ctrd <- st_centroid(poly, of_largest_polygon = TRUE)
  in_poly <- diag(st_within(ctrd, poly, sparse = F))

  # replace geometries that are not within polygon with st_point_on_surface()
  st_geometry(ctrd[!in_poly,]) <- st_geometry(st_point_on_surface(poly[!in_poly,]))

  ctrd
}


for (i in 1:ceiling(numberOfRows/linesLimit)) {

print(paste("Pass ",i," of ",ceiling(numberOfRows/linesLimit),"...",sep=""))
shape=st_read(path)

###Divides to deal with RAM
if (i*linesLimit > numberOfRows) {
	shape = shape[c(((i-1)*linesLimit+1):numberOfRows),]
} else {
	shape = shape[c(((i-1)*linesLimit+1):(i*linesLimit)),]
}
gc()

###Gets WKT
if(st_geometry_type(shape, by_geometry = TRUE)[1] != "POINT"){
	print("Fetching footprintWKT...")
	wkt <- writeWKT(as_Spatial(shape), byid = TRUE)
	dataframedWKT <-  data.frame(footprintWKT  = wkt)
	rm(wkt)
	gc()
}

####Converts shape to UTF-8 and gets the inner centroids in the original SRS
print("Fetching verbatimLongitude and verbatimLatitude...")
shape=shape %>%
  dplyr::mutate_if(is.character, iconv, from = encoding, to = 'UTF-8' ) %>% 
   st_centroid_within_poly ()  
  
###Converts to dataframe and cleans the needless columns generated by the intersect
dataframed <- as(as_Spatial(shape),"data.frame")
dataframed <- dataframed[,!(colnames(dataframed) %in% c("path","layer","NOFORIGIN","EOFORIGIN","CELLCODE"))]
gc()

###Changes the name of the centroids to the correct ones and adds the SRS columns
colnames(dataframed)[ncol(dataframed)] <- "verbatimLatitude"
colnames(dataframed)[ncol(dataframed)-1] <- "verbatimLongitude"

if (exists("dataframedWKT")) {
	withWKT <- cbind(dataframed,dataframedWKT)
	withWKT <- cbind(withWKT,rep(st_crs(shape)$input,nrow(withWKT)))
	colnames(withWKT)[ncol(withWKT)] <- "footprintSRS"
} else {
	withWKT <- dataframed
}
withWKT <- cbind(withWKT,rep(st_crs(shape)$input,nrow(withWKT)))
colnames(withWKT)[ncol(withWKT)] <- "verbatimSRS"

rm(dataframedWKT,dataframed)
gc()


###Converts the shape to WGS84 and gets the centroids 
   print("Fetching decimalLongitude and decimalLatitude...")
shape=shape %>%
  st_transform(4326) %>%  
  st_centroid_within_poly ()  
dataframedWGS84 <- as(as_Spatial(shape),"data.frame")
colnames(dataframedWGS84)[ncol(dataframedWGS84)] <- "decimalLatitude"
colnames(dataframedWGS84)[ncol(dataframedWGS84)-1] <- "decimalLongitude"
  
 withWGS84 <- cbind(withWKT,dataframedWGS84 [ncol(dataframedWGS84)-1])
 withWGS84 <- cbind(withWGS84,dataframedWGS84 [ncol(dataframedWGS84)]) 
 withWGS84 <- cbind(withWGS84,rep("WGS84",nrow(withWGS84)))
colnames(withWGS84)[ncol(withWGS84)] <- "geodeticDatum"
rm(withWKT,dataframedWGS84)
 gc()

  

### Gets the locations of the points in WGS84 from the CAOP202 shape also in WGS84
print("Fetching locations...")

shape <- point.in.poly(shape, CAOP)

withWGS84<- cbind(withWGS84,shape$Ilha)
colnames(withWGS84)[ncol(withWGS84)] <- "island"
withWGS84<- cbind(withWGS84,shape$Distrito)
colnames(withWGS84)[ncol(withWGS84)] <- "stateProvince"
withWGS84<- cbind(withWGS84,shape$Concelho)
colnames(withWGS84)[ncol(withWGS84)] <- "municipality"
withWGS84 <- cbind(withWGS84, ifelse(is.na(shape$Des_Simpli), shape$Freguesia, shape$Des_Simpli))
colnames(withWGS84)[ncol(withWGS84)] <- "locality"


#withWGS84<- cbind(withWGS84,shape$Des_Simpli)
#colnames(withWGS84)[ncol(withWGS84)] <- "locality"
#withWGS84<- cbind(withWGS84,shape$Freguesia)
#colnames(withWGS84)[ncol(withWGS84)] <- "localityIlhas"



gc()

###Para nÃ£o ir a baixo com pontos
	shape=st_read(path)
if (.hasSlot(as_Spatial(shape),"polygons") || .hasSlot(as_Spatial(shape),"lines")  ) {


####### para se adaptar a linhas/vs polygons
	if(st_geometry_type(shape, by_geometry = TRUE)[1] == "MULTILINESTRING" || st_geometry_type(shape, by_geometry = TRUE)[1] == "LINESTRING") {
		SlotCall = "Lines"
		slotCall = "lines"	
		} else {
		SlotCall = "Polygons"
		slotCall = "polygons"
	}

	####Coord Uncertainty in Meters (that is, gets the uncertainty in the original SRS, likely meters with our datasets so OK)
	print("Calculating coordinateUncertaintyInMeters...")

	###Divides to deal with RAM
	if (i*linesLimit > numberOfRows) {
		shape = shape[c(((i-1)*linesLimit+1):numberOfRows),]
	} else {
		shape = shape[c(((i-1)*linesLimit+1):(i*linesLimit)),]
	}
	gc()
	
	coordAcc <- mapply(coordCalc,slot(as_Spatial(shape),slotCall),withWGS84[,ncol(withWGS84)-11],withWGS84[,ncol(withWGS84)-10],TRUE,SlotCall)

	temp <-  data.frame(coordinateUncertaintyInMeters  = coordAcc)
	 withWGS84 <- cbind(withWGS84,temp)
	 
	 ####Coord precision (that is, gets the uncertainty in WGS84, so degrees, as required)
	 print("Calculating coordinatePrecision...")
	shape=st_read(path)

	###Divides to deal with RAM
	if (i*linesLimit > numberOfRows) {
		shape = shape[c(((i-1)*linesLimit+1):numberOfRows),]
	} else {
		shape = shape[c(((i-1)*linesLimit+1):(i*linesLimit)),]
	}
	gc()
	 shape=shape %>%
	  st_transform(4326)
	  gc()

	coordAcc <- mapply(coordCalc,slot(as_Spatial(shape),slotCall),withWGS84[,ncol(withWGS84)-7],withWGS84[,ncol(withWGS84)-6],FALSE,SlotCall)

	temp <-  data.frame(coordinatePrecision  = coordAcc)

	withWGS84 <- cbind(withWGS84,temp)
}

if (i == 1) {
	finalOutput <- withWGS84
} else {
	finalOutput <- rbind(finalOutput,withWGS84)
}
rm(withWGS84)
gc()
}

#### Removes NAs
finalOutput[is.na(finalOutput)] <- ""
 

 ####Writes the output to a CSV
con<-file(paste(output_path,"script_output.csv",sep=""),encoding="UTF-8")
write.csv(finalOutput,file=con) 

##Clears memory
rm(list = ls())
gc()
